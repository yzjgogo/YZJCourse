package com.yin.yzjcourse.DesignModel.P11代理模式;

/**
 * 代理模式：为另一个对象提供一个替身或占位符以控制对这个对象的访问。
 * 代理其实就是目标对象的代表，你想访问目标对象，你得通过代理访问。
 *
 * 代理模式要求代理类和目标类都实现同一个接口，这样就保证了任何客户代码都
 * 可以处理目标对象一样处理代理对象，也就是客户代码只关心抽象对象，不关心具体对象，依赖抽象不依赖具体类。
 *
 * 代理模式会有很多变型，例如我们提到的远程代理、虚拟代理、保护代理等等。但是他们的类图大致相同，也可能会有所扩展。
 *
 *
 *
 *  设计原则：
 *  封装变化：被代理的类可能有变化，但是客户代码无需关心，只需通过代理类访问即可，实际上客户代码根本不知道自己调用的是代理。
 *  多用组合，少用集成：
 *  针对接口编程，不针对实现编程：代理类和目标类都有共同的接口，客户代码只关心接口类型，不关心具体类。
 *  为交互对象之间的松耦合设计而努力：客户代码与目标类完全解耦。
 *  类应该对扩展开放，对修改关闭(开闭原则)：
 *  依赖抽象，不依赖具体类(依赖倒置原则)：代理类和目标类都有共同的接口，客户代码只关心接口类型，不关心具体类。
 *  只和朋友交谈(最少知识原则)：
 *  别找我，我会找你(好莱坞原则)：客户代码单项调用代理类，代理类单项调用处理器Handler.
 *  类应该只有一个改变的理由(单一职责原则)：
 *
 * 参考图片：proxy_uml.png
 */
public class ProxyIntorduce {
}
