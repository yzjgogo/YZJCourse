package com.yin.yzjcourse.DesignModel.P8模板方法模式;

import com.yin.yzjcourse.DesignModel.P8模板方法模式.子类中实现模板方法.CoffeeWithHook;
import com.yin.yzjcourse.DesignModel.P8模板方法模式.子类中实现模板方法.TeaWithHook;

/**
 * 模板方法模式：在一个方法中定义一个算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以在不改变算法解构的
 *              情况下，个性化定义算法中的某些步骤。
 *  注意点：
 *  0：抽象的模板方法其实就是算法的大纲，只是有些细节需要子类去完善，但是子类无法改变算法的整体逻辑。
 *  1：末班方法定义在抽象的父类中，且也是一个抽象的方法。
 *  2：抽象的模板方法一般定义成final的，因为末班方法应该是抽象的约定，所有子类必须遵守，不可篡改；
 *  3：抽象的模板方法中可能会调用到多个方法，部分方法可能在抽象父类中已经实现，且这些已经实现的方法可以根据需要是否用final修饰；
 *      部分方法可能是抽象的，这才是模板方法的精髓，这部分抽象的方法由子类定制化实现。因为不同的子类可能实现方式不同；
 *  4：抽象的模板方法中可以根据需要定义钩子方法，这个钩子方法可以有默认的实现也可有是空方法，子类可以根据需要决定是否重写。
 *  5：模板方法是很灵活的，一般有很多变形，模板方法中定义的那些子方法，可能是在一大堆复杂的逻辑中逐个引用到的，而不像我们的例子中
 *      那样一次性连续调用，平时注意区分。
 *
 *  设计模式：
 *  封装变化：模板方法中那些需要由子类实现的抽象方法，就是易变的部分，通过一个抽象方法封装，然后各个子类具体实现；
 *  多用组合，少用继承：
 *  针对接口编程，不针对实现编程：
 *  为交互对象之间的松耦合设计而努力：
 *  类应该对扩展开放，对修改关闭：这里，抽象的父类的模板方法定义成final的，是所有子类的约定必须遵守，但是也提供了一些
 *                              抽象方法让子类自由实现，以扩展父类的功能，钩子方法也是一个扩展的途径。
 *  依赖抽象，不要依赖具体类：
 *  只和朋友交谈：
 *  #别主动找我，我会叫你的(好莱坞原则)：这里，抽象的父类操控一切，当父类需要的时候回去调用子类实现的抽象方法，而子类一般
 *                                  不应该主动去调用父类。
 *
 */
public class TemplateMethodTest {
	public static void main(String[] args) {

 
		TeaWithHook teaHook = new TeaWithHook();
		CoffeeWithHook coffeeHook = new CoffeeWithHook();
 
		System.out.println("\nMaking tea...");
		teaHook.prepareRecipe();
 
		System.out.println("\nMaking coffee...");
		coffeeHook.prepareRecipe();
	}
}
